### From https://levelup.gitconnected.com/transformer-squared-stop-finetuning-llms-4d6b1aee8425
### From https://arxiv.org/abs/2501.06252v3


Introduction and Motivation
Current Capabilities and Limitations:
Modern LLMs can write coherent prose, solve complex questions, and generate code with impressive skill. However, when these models are applied to specific tasks (e.g., coding, math problem-solving), finetuning becomes necessary. Finetuning is effective but has notable drawbacks:

It is computationally expensive and time-consuming.
Each finetuning process creates a new, static version of the model.
If a model needs to adapt to a new task or domain, additional finetuning is required.
The Need for On-the-Fly Adaptation:
The text argues for a smarter, more dynamic alternative where LLMs can adapt in real timeâ€”adjusting internal mechanisms â€œon the flyâ€ rather than undergoing full-scale retraining every time the task changes.

Proposal â€“ TransformerÂ²:
A recent paper titled â€œTransformer-Squared: Self-adaptive LLMsâ€ by Sun, Cetin, and Tang (Sakana AI) introduces TransformerÂ². This framework aims to enable LLMs to adapt dynamically through a novel approach based on Singular Value Decomposition (SVD) and a technique called Singular Value Fine-tuning (SVF), combined with reinforcement learning.

Core Methodology of TransformerÂ²
Singular Value Decomposition (SVD):

Any weight matrix 
ğ‘Š
W in a neural network can be decomposed into three matrices: 
ğ‘Š
=
ğ‘ˆ
Î£
ğ‘‰
ğ‘‡
W=UÎ£V 
T
 .
ğ‘ˆ
U and 
ğ‘‰
V are semi-orthogonal matrices representing input and output directions.
Î£
Î£ is a diagonal matrix containing singular values 
ğœ
ğ‘–
Ïƒ 
i
â€‹
  that quantify the â€œimportanceâ€ or strength of each component in the transformation.
Singular Value Fine-tuning (SVF):

Instead of adjusting all parameters during finetuning, TransformerÂ² focuses on modifying only the singular values in 
Î£
Î£.
This is done by learning a small â€œexpert vectorâ€ 
ğ‘§
z which is element-wise multiplied with the singular values:
Î£
â€²
=
Î£
âŠ—
diag
(
ğ‘§
)
Î£ 
â€²
 =Î£âŠ—diag(z)
The adapted weight matrix becomes:
ğ‘Š
â€²
=
ğ‘ˆ
Î£
â€²
ğ‘‰
ğ‘‡
W 
â€²
 =UÎ£ 
â€²
 V 
T
 
This approach is highly parameter-efficient because 
ğ‘§
z is much smaller than the full weight matrices.
Two-Pass Inference Mechanism:

First Pass:
The model processes an input prompt with its base, pre-trained weights to â€œassessâ€ the task.
Second Pass:
Based on the initial assessment, the model selects and mixes the appropriate expert vectors (e.g., for math, coding, reasoning). The weight matrices are adapted on the fly using the chosen expert vector 
ğ‘§
â€²
z 
â€²
 , and the final output is generated with these updated parameters.
Training with Reinforcement Learning (RL):

The expert vectors are trained using RL to optimize task performance.
The RL objective includes a reward signal based on how correct the generated output is relative to the ground truth.
A KL divergence term is included to prevent the adapted model from diverging too much from the original model, thus regularizing the adaptation.
This allows the system to directly optimize for performance on specific tasks while making minimal adjustments.
Code Implementation and System Architecture
Repository and Configuration Management:

The researchers released a GitHub repository (SakanaAI/self-adaptive-llms) containing the implementation.
The main script (svd_reinforce_hydra.py) orchestrates the entire adaptation process.
Hydra and OmegaConf are used to load experiment settings (iterations, batch size, model selection, etc.) via YAML configuration files, ensuring flexible and reproducible experiments.
SVD Decomposition in Code:

The script checks for existing decomposed parameters; if not found, it performs SVD on select weight matrices (skipping layers like normalization) and saves the components 
ğ‘ˆ
U, 
ğ‘†
S (singular values), and 
ğ‘‰
V.
This selective decomposition reduces unnecessary computation.
Policy Initialization and Optimization:

A policy network is instantiated to generate expert vectors that modulate the singular values.
The policy uses methods (e.g., sigmoid followed by scaling with a parameter such as max_mult) to produce a mask applied to the singular values.
The system supports combining multiple expert vectors, loading them from checkpoints, and managing these parameters via PyTorchâ€™s buffer system.
The training loop samples batches of data, applies the current policy to modify singular values, processes the batch, computes a reward signal, and updates the expert vectors accordingly.
Evaluation Mechanism:

The framework employs a two-phase evaluation system: first classifying the prompt to decide which expert vector to use, then processing the input with the adapted model.
Detailed metrics are logged (including training/validation losses, test accuracies, and policy behavior) for comprehensive monitoring of the adaptation process.
Advantages and Broader Impact
Efficiency:

By learning only the compact expert vector 
ğ‘§
z to modulate singular values, TransformerÂ² reduces the number of trainable parameters significantly compared to full-model finetuning.
This leads to lower computational costs, faster training cycles, and reduced storage requirements.
Real-Time Adaptability:

The two-pass inference mechanism allows the model to dynamically adjust its internal weights based on the task at hand without requiring separate finetuned models.
This enables a single model to fluidly switch between different tasks (e.g., coding, math, creative writing) by adjusting its â€œinternal gears.â€
Versatility and Generalization:

TransformerÂ² is designed to be architecture-agnostic and may extend to various model families (e.g., Llama, Mistral) and even different modalities (such as vision-language tasks).
The concept of expert vectors opens the possibility for knowledge transfer and combining expertise from multiple domains.
Potential for Improved Interpretability:

By modulating singular values, the method might allow for more modular and interpretable adjustments, shedding light on which fundamental components of the weight matrices are being tuned for specific tasks.
Open Questions and Future Directions
Complexity of Adaptation Strategies:

Determining the best adaptation strategy (e.g., prompt-based, classifier-based, few-shot) for a given task is still an open question.
Developing robust mechanisms for dispatching expert vectors remains an area for further research.
Generalization and Robustness:

The approach needs extensive evaluation across a broader range of tasks, datasets, and real-world scenarios to confirm its robustness and generalization capabilities.
Its performance under noisy or ambiguous inputs is yet to be fully explored.
Scalability with Numerous Experts:

As the number of specialized domains grows, managing and combining a large library of expert vectors efficiently will be challenging.
Future research may need to explore efficient organization and selection methods for expert vectors.
Trade-Offs between Adaptation Speed and Performance:

The two-pass inference mechanism introduces some overhead. A careful analysis of the balance between real-time adaptation speed and final output performance is necessary, especially for latency-sensitive applications.
Conclusion
A Paradigm Shift:
TransformerÂ² represents a fundamental shift away from traditional finetuning. Instead of retraining large portions of a modelâ€™s parameters, it adapts a model by adjusting only its singular values via lightweight expert vectors.

Core Innovations:

Singular Value Fine-tuning (SVF): Focuses on efficiently modulating the core â€œstrengthsâ€ of weight matrices.
Two-Pass Inference: Enables dynamic, real-time adaptation based on the specific demands of the input prompt.
Implications for the Future:

This approach promises enhanced efficiency, significant computational savings, and the potential for a single LLM to handle diverse tasks without requiring separate specialized finetuned versions.
While early and subject to further validation, TransformerÂ² challenges the current model of static finetuning and points toward a future where LLMs adapt in real time, potentially reshaping the landscape of AI applications.
